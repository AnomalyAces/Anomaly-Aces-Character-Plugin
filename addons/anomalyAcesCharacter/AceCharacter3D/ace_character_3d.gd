@tool
extends CharacterBody3D
## Anomaly Aces 3D Character Node that handles sprites, camera_host, and input movement
## 
## Blah Blah Blah
class_name AceCharacter3D

## Controls the movement mode of the character [br]
## [b]FREE[/b] - Free form movement [br]
## [b]BOARD[/b] - Movement restricted to a board generated by [AceBoardGenerator]
enum MOVEMENT_MODE {FREE, BOARD}

##AceSprite3D
@export var sprite: AceSprite3D = null :
	set(p_sprite):
		sprite = p_sprite
		update_configuration_warnings()

##AceCamera3D - Camera that contains the PhantomCameraHost
@export var camera: AceCamera3D = null :
	set(p_cam_host):
		camera = p_cam_host
		update_configuration_warnings()




## Changes with the camera_host angle
@export var tileMapOffset: Vector3 = Vector3(0.5,0,0.5)

@export_group("Movement")

## Disable Inputs
@export var enableInput: bool = true
## Movement Mode
@export var movementMode: MOVEMENT_MODE = MOVEMENT_MODE.FREE :
	set(p_mode):
		movementMode = p_mode
		notify_property_list_changed()
## Movement speed of character
@export var speed = 2
## Jump Velocity of character
@export var jumpVelocity = 9
# Get the gravity from the project settings to be synced with RigidBody nodes.
@export var gravity: float = ProjectSettings.get_setting("physics/3d/default_gravity")
## Enables or disables diagonal movement: Default false (no diagonal movement)
@export var hasDiagonalMovement: bool = false
@export_subgroup("Input Mappings")
@export var inputMap: AceInputMap :
	set(p_input_map):
		inputMap = p_input_map
		_input_map_valid = _is_input_map_valid()
		update_configuration_warnings()
@export var inputTypes: Dictionary[MOVEMENT_MODE, AceCharacterInput] :
	set(p_input_types):
		inputTypes = p_input_types
		update_configuration_warnings()

@export_subgroup("")

##Board Varibles
@export_group("Board")
## GridMap
@export var gridMap: GridMap
## Space Editor used to track spaces
@export var spaceEditor: SpaceEditor



## State Variables for character
var _input_map_valid: bool = false
var _print_input_map_invalid_msg: bool = true
var _input_enabled: bool = true;

var curr_path_target: Vector3 = Vector3.INF
var path: Array[Vector3] = []

func _ready() -> void:
	pass


func _get_configuration_warnings() -> PackedStringArray:
	var warnings: PackedStringArray

	#Check Spritee
	if sprite == null:
		warnings.append("A child node of type AceSprite3D is needed")

	#Check camera_host
	if camera == null:
		warnings.append("A child node of type AceCamera3D is needed")

	#Check Input 
	if inputMap == null:
		warnings.append("A child node of type AceInputMap is needed")
	
	#Check Input Types
	if inputTypes == null:
		warnings.append("A Dictionary[MOVEMENT_MODE, AceCharacterInput] defining inputs for each movement mode is needed")
	else:
		for input in inputTypes:
			if inputTypes.get(input) == null:
				warnings.append("Input for movemnent mode %s is not assigned" % MOVEMENT_MODE.find_key(input))
	
	var children: Array[Node] = get_children()
	var ace_character_inputs: Array[AceCharacterInput] = [] 
	ace_character_inputs.assign(children.filter(func(child): return child is AceCharacterInput))

	if ace_character_inputs.size() == 0:
		var board_input_scene = load("res://addons/anomalyAcesCharacter/AceCharacterInput/AceCharacterBoardInput/AceCharacterBoardInput.tscn")
		var free_input_scene = load("res://addons/anomalyAcesCharacter/AceCharacterInput/AceCharacterFreeInput/AceCharacterFreeInput.tscn")
		var board_input = board_input_scene.instantiate()
		var free_input = free_input_scene.instantiate()
		add_child(board_input)
		add_child(free_input)
		
		board_input.owner = get_tree().edited_scene_root
		board_input.character = self
		board_input.input_map = inputMap
		
		free_input.owner = get_tree().edited_scene_root
		free_input.character = self
		free_input.input_map = inputMap

		inputTypes.set(MOVEMENT_MODE.FREE, free_input)
		inputTypes.set(MOVEMENT_MODE.BOARD, board_input)




	
	
	return warnings

func _physics_process(delta: float) -> void:

	# _normalize_position()

	if not _input_map_valid:
		if _print_input_map_invalid_msg:
			AceLog.printLog(["Input Map not configured properly on %s. Checking for updates every 1 min..." % get_script().get_global_name()], AceLog.LOG_LEVEL.WARN)
			_print_input_map_invalid_msg = false
			get_tree().create_timer(60).timeout.connect(_on_print_timeout)
		return

	if inputTypes.get(movementMode) != null:

		inputTypes.get(movementMode).process_character_input(delta)

	

func update_path(new_path: Array[Vector3i]):
	path.assign(new_path.map(func(path): return Vector3(path)+tileMapOffset))
	_find_next_point_in_path()

func add_target_to_path(target: Vector3):
	path.push_back(target)
	_find_next_point_in_path()

func calculate_move_stats(cur: Vector3, delta: float, has_verticle_stats: bool = false) -> AceMoveStats :
	var stats: AceMoveStats = AceMoveStats.new()
	stats.displacement = cur - global_transform.origin
	if !has_verticle_stats:
		# remove y component if ignoring verticle stats
		stats.displacement.y = 0
	
	
	stats.direction = stats.displacement.normalized()
	stats.distance = stats.displacement.length()
	
	var max_speed := (stats.distance / delta)
	stats.velocity = stats.direction * minf(speed, max_speed)
	
	if !has_verticle_stats:
		# remove y component if ignoring verticle stats
		stats.velocity.y = 0
	
	return stats
#Center player on board space if not centered and selected movement mode is 'BOARD'
func _normalize_position():
	if movementMode == MOVEMENT_MODE.BOARD && _input_enabled:
		var int_pos_vec: Vector3i = Vector3i(position)
		var target_pos: Vector3 = Vector3(int_pos_vec) + tileMapOffset
		target_pos.y = position.y
		if position != target_pos:
			position = target_pos


func _find_next_point_in_path():
	if path.size() > 0:
		var new_target = path.pop_front()
		new_target.y = global_transform.origin.y
		curr_path_target = new_target
	else:
		curr_path_target = Vector3.INF


func _validate_property(property: Dictionary) -> void:
	var board_props: Array[String]  = ["gridMap", "spaceEditor"]

	if property.name in board_props and movementMode != MOVEMENT_MODE.BOARD:
		property.usage = PROPERTY_USAGE_NO_EDITOR
	if property.name in board_props and movementMode == MOVEMENT_MODE.BOARD:
		property.usage = PROPERTY_USAGE_DEFAULT 

func _is_input_map_valid() -> bool:
	return inputMap._input_map_valid

func _on_print_timeout() -> void:
	_print_input_map_invalid_msg = true
