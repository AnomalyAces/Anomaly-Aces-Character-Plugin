@tool
class_name AceCharacter3D extends CharacterBody3D

## Controls the movement mode of the character [br]
## [b]FREE[/b] - Free form movement [br]
## [b]BOARD[/b] - Movement restricted to a board generated by [AceBoardGenerator]
enum MOVEMENT_MODE {FREE, BOARD}

## Changes with the camera angle
@export var tileMapOffset: Vector3 = Vector3(0,0,-2)

@export_group("Movement")
## Movement Mode
@export var movement_mode: MOVEMENT_MODE = MOVEMENT_MODE.FREE :
	set(p_mode):
		movement_mode = p_mode
		notify_property_list_changed()
## Movement speed of character
@export var speed = 2
## Jump Velocity of character
@export var jump_velocity = 9
## Enables or disables diagonal movement: Default false (no diagonal movement)
@export var has_diagonal_movement: bool = false
@export_subgroup("Input Map")
@export var north_input: String :
	set(p_north):
		north_input = p_north
		update_configuration_warnings()
		_input_map_valid = _is_input_map_valid()
@export var east_input: String :
	set(p_east):
		east_input = p_east
		update_configuration_warnings()
		_input_map_valid = _is_input_map_valid()
@export var south_input: String:
	set(p_south):
		south_input = p_south
		update_configuration_warnings()
		_input_map_valid = _is_input_map_valid()
@export var west_input: String :
	set(p_west):
		west_input = p_west
		update_configuration_warnings()
		_input_map_valid = _is_input_map_valid()
@export_subgroup("")

##Board Varibles
@export_group("Board")
## GridMap
@export var gridMap: GridMap
## Space Editor used to track spaces
@export var spaceEditor: SpaceEditor

## State Variables for character
var _input_map_valid: bool = false
var _print_input_map_invalid_msg: bool = true



var curr_path_target: Vector3 = Vector3.INF
var path: Array[Vector3] = []

func _ready() -> void:
	_input_map_valid = _is_input_map_valid()
	if Engine.is_editor_hint():
		var custom_inputs: Array[String] = []
		custom_inputs.assign([north_input, east_input, south_input, west_input].filter(func(input: String): return !input.is_empty()))
		print("Adding Temp Actions to Editor InputMap to quiet errors")
		print("=========Project Settings===========")
		for input in custom_inputs:
			print("Adding %s" % input)
			InputMap.add_action(input)
		print("====================================")
	pass


func _get_configuration_warnings() -> PackedStringArray:
	var warnings: PackedStringArray

	#Check Input 
	if north_input.is_empty():
		warnings.append("north_input is empty")
	if east_input.is_empty():
		warnings.append("east_input is empty")
	if south_input.is_empty():
		warnings.append("south_input is empty")
	if west_input.is_empty():
		warnings.append("west_input is empty")

	
	
	return warnings

func _physics_process(delta: float) -> void:

	if not _input_map_valid:
		if _print_input_map_invalid_msg:
			push_warning("Input Map not configured properly on %s. Checking for updates every 1 min..." % get_script().get_global_name())
			_print_input_map_invalid_msg = false
			get_tree().create_timer(60).timeout.connect(_on_print_timeout)
		return

	## If the mode is FREE do the following
	if movement_mode == MOVEMENT_MODE.FREE:
		# Get the input direction and handle the movement/deceleration.
		# As good practice, you should replace UI actions with custom gameplay actions.
		var input_dir := Input.get_vector(west_input, east_input, north_input, south_input)
		var direction := (transform.basis * Vector3(input_dir.x, 0, input_dir.y)).normalized()
		if direction:
			velocity.x = direction.x * speed
			velocity.z = direction.z * speed
		else:
			velocity.x = move_toward(velocity.x, 0, speed)
			velocity.z = move_toward(velocity.z, 0, speed)
		
		move_and_slide()

	## If the mode is BOARD do the following
	if movement_mode == MOVEMENT_MODE.BOARD:
		## This follows the assigned path
		if curr_path_target != Vector3.INF:
			var move_stats: AceMoveStats = calculate_move_stats(curr_path_target, delta)
			velocity = move_stats.velocity
			
			if is_zero_approx(move_stats.distance):
				_find_next_point_in_path()
			else:
				move_and_slide()
		else:
			# If the current target has not been set yet listen for a new target
			if curr_path_target == Vector3.INF:
				var input_dir := Input.get_vector(west_input, east_input, north_input, south_input)
				
				if !has_diagonal_movement:
					# stop diagonal movement by listening for left/right input then setting y axis to zero
					if Input.is_action_pressed(east_input) || Input.is_action_pressed(west_input):
						input_dir.y = 0
						var target: Vector3 = position + Vector3(input_dir.x,0,input_dir.y)
						if BoardGeneratorGridUtil.isLocationDefinedSpace(target, gridMap, spaceEditor):
							curr_path_target = target
					# stop diagonal movement by listening for  up/down input then setting x axis to zero
					elif Input.is_action_pressed(north_input) || Input.is_action_pressed(south_input):
						input_dir.x = 0
						var target: Vector3 = position + Vector3(input_dir.x,0,input_dir.y)
						if BoardGeneratorGridUtil.isLocationDefinedSpace(target, gridMap, spaceEditor):
							curr_path_target = target
					else:
						input_dir = Vector2.ZERO
				else:
					var target: Vector3 = position + Vector3(input_dir.x,0,input_dir.y)
					if BoardGeneratorGridUtil.isLocationDefinedSpace(target, gridMap, spaceEditor):
						curr_path_target = target
	
	

func update_path(new_path: Array[Vector3i]):
	path.assign(new_path.map(func(path): return Vector3(path)+tileMapOffset))
	_find_next_point_in_path()

func calculate_move_stats(cur: Vector3, delta: float, has_verticle_stats: bool = false) -> AceMoveStats :
	var stats: AceMoveStats = AceMoveStats.new()
	stats.displacement = cur - global_transform.origin
	if !has_verticle_stats:
		# remove y component if ignoring verticle stats
		stats.displacement.y = 0
	
	stats.direction = stats.displacement.normalized()
	stats.distance = stats.displacement.length()
	
	var max_speed := (stats.distance / delta)
	stats.velocity = stats.direction * minf(speed, max_speed)
	
	if !has_verticle_stats:
		# remove y component if ignoring verticle stats
		stats.velocity.y = 0
	
	return stats

func _find_next_point_in_path():
	if path.size() > 0:
		var new_target = path.pop_front()
		new_target.y = global_transform.origin.y
		curr_path_target = new_target
	else:
		curr_path_target = Vector3.INF


func _is_input_map_valid() -> bool:
	for input in [west_input, east_input, north_input, south_input]:
		if input.is_empty():
			return false
	return true

func _on_print_timeout() -> void:
	_print_input_map_invalid_msg = true
